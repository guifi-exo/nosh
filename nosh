#!/bin/bash

# nosh - network operator shell
# version: 1.2

# Original autor Yeti => src https://stackoverflow.com/a/43793768
# Why don't you write your own login-shell? It would be quite simple to use Bash for this, but you can use any language.
# Example in Bash
# Use your favorite editor to create the file /root/rbash.sh (this can be any name or path, but should be chown root:root and chmod 700):
# All you have to do is set this executable as your login shell. For example, edit your /etc/passwd file, and replace your current login shell of that user /bin/bash with /root/rbash.sh.
# This is just a simple example, but you can make it as advanced as you want, the idea is there. Be careful to not lock yourself out by changing login shell of your own and only user. And always test weird symbols and commands to see if it is actually secure.
# You can test it with: su -s /root/rbash.sh.
# Beware, make sure to match the whole command, and be careful with wildcards! Better exclude Bash-symbols such as ;, &, &&, ||, $, and backticks to be sure.
# Depending on the freedom you give the user, it won't get much safer than this. I've found that often I only needed to make a user that has access to only a few relevant commands, and in that case this is really the better solution. However, do you wish to give more freedom, a jail and permissions might be more appropriate. Mistakes are easily made, and only noticed when it's already too late.

# src https://unix.stackexchange.com/questions/29494/disable-bash-tab-completion
# warning I'm ignoring is: `bind: warning: line editing not enabled`
bind 'set disable-completion on' &> /dev/null

commands=("uptime" "ping" "traceroute" "ssh" "mtr" "nc")
timestamp(){ date +'%Y-%m-%s %H:%M:%S'; }
log(){ echo -e "$(timestamp)\t$1\t$USER\t$2" >> /tmp/nosh.log; }
trycmd()
{
    # Provide an option to exit the shell
    if [[ "$ln" == "exit" ]] || [[ "$ln" == "q" ]] || [[ "$ln" == "quit" ]]
    then
        exit

    # illegal symbols; bash symbols -> src https://www.tldp.org/LDP/abs/html/special-chars.html
    elif [[ "$ln" =~ [\;\&\|\$\<\>\(\)\{\}\[\!\*\?\=\+\%\^] ]]
    then
        echo 'You cannot use the following symbols: ;, &, |, $, <, >, `, (, ), {, }, [, !, *, ?, =, +, %, ^'

    # You can do exact string matching for some alias:
    elif [[ "$ln" == "help" ]] || [[ "$ln" == "h" ]]
    then
        echo "Type 'exit', 'quit' or 'q' to quit."
        echo "Commands you can use:"
        echo "  help or h"
        echo "${commands[@]}" | tr ' ' '\n' | awk '{print "  " $0}'

    elif [[ "$ln" == "" ]]
    then
        echo

    # TODO use getopt
    elif [[ "$ln" =~ ^$'ping -n'\ .*$ ]]
    then
        ln="${ln:8}"
        ping -n "$ln"

        log COMMAND "ping -n $ln"

    elif [[ "$ln" =~ ^ping\ .*$ ]]
    then
        ln="${ln:5}"
        ping "$ln"

        log COMMAND "ping $ln"

    # TODO use getopt
    elif [[ "$ln" =~ ^$'traceroute -n'\ .*$ ]]
    then
        ln="${ln:14}"
        traceroute -n "$ln"

        log COMMAND "traceroute -n $ln"

    elif [[ "$ln" =~ ^traceroute\ .*$ ]]
    then
        ln="${ln:11}"
        traceroute "$ln"

        log COMMAND "traceroute $ln"

    elif [[ "$ln" =~ ^ssh\ .*$ ]]
    then
        ln="${ln:4}"
        ssh "$ln"

        log COMMAND "ssh $ln"

    elif [[ "$ln" =~ ^mtr\ .*$ ]]
    then
        ln="${ln:4}"
        mtr "$ln"

        log COMMAND "mtr $ln"

    # validate IPv4 and port for nc command -> src http://www.linuxjournal.com/content/validating-ip-address-bash-script
    elif [[ "$ln" =~ ^nc\ [0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\ [0-9]{1,5}$ ]]
    then
        ln="${ln:3}"
        eval nc "$ln"

        log COMMAND "nc $ln"

    elif [[ "$ln" =~ ^nc\ .*$ ]]
    then
        echo "nc is extraprotected because uses dangerous eval. It only supports IPv4. You need IPv6? Fill an issue and tell us specific use case."

    # Or you could even check an array of commands:
    else
        ok=false
        for cmd in "${commands[@]}"
        do
            if [[ "$cmd" == "$ln" ]]
            then
                ok=true
            fi
        done
        if $ok
        then
            $ln
        else
            log DENIED "$ln"
            echo "command disabled"
        fi
    fi
}

# Optionally log the login
log LOGIN "$@"

# Optionally log the logout
trap "trap=\"\";log LOGOUT;exit" EXIT
# Trap Ctrl-C / ^C (signal 2) to avoid exit this way -> src https://www.cyberciti.biz/faq/unix-linux-shell-scripting-disable-controlc/
trap '' 2

# Optionally check for '-c custom_command' arguments passed directly to shell
# Then you can also use ssh user@host custom_command, which will execute /root/rbash.sh
if [[ "$1" == "-c" ]]
then
    shift
    ln="$@"
    trycmd "$@"
else

    # Optionally show a friendly welcome-message with instructions since it is a custom shell
    echo
    echo "Welcome, $USER."
    echo "nosh 1.2 - Network Operator Shell, a shell with very few commands available"
    echo "Source code: https://github.com/guifi-exo/nosh/blob/master/nosh"
    echo "Type 'help' or 'h' for information."
    echo
    echo "Commands are logged, you accessed in $(timestamp)"
    echo

    # note: tab completion cannot be provided -> src https://stackoverflow.com/questions/4726695/bash-and-readline-tab-completion-in-a-user-input-loop
    # -e enables readline capabilities
    while read -p "nosh> " -e ln
    do
        # because readline functionality -> src https://www.unix.com/shell-programming-and-scripting/253648-bash-read-history-function-read-arrowkeys.html
        history -s "$ln"
        trycmd "$ln"
    done
fi
